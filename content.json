{"pages":[],"posts":[{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2020/05/20/hello-world/"},{"title":"mysql查询优化","text":"设置分区分区不仅可以提高查询效率，也可以方便对数据库中的数据进行管理。 在没有分区的情况下，表中的数据都存储在同一个文件里，在建立分区以后，表中的文件可以按照分区的规则芬芳在不同的小文件里，在查询的时候指定分区，则会去小文件中执行查询，可以提高查询效率。 以时间分区为例，如果我们创建分区的字段是time，不同时间的相关数据被存储在不同的数据库文件里，如果我们要删除2018年的数据，就可以直接删除2018年所在的分区，不仅提高速度，也可以减少sql语句的长度。 创建分区分区可以在创建数据库的时候一并创建，平时主要用mysql，所以以mysql为例 1234567CREATE TABLE `user_info` ( `time` INT NOT NULL COMMENT '分区时间', `user_id` BIGINT COMMENT '用户ID', `user_name` VARCHAR(128) COMMENT '用户名称') PARTITION BY LIST(time) ( PARTITION p_default VALUES IN (0)); 上面的代码表示，创建一个存储用户信息的数据库表，其中PARTITION BY LIST(time) (PARTITION p_default VALUES IN (0));语句表示基于time字段创建分区，p_default是分区名称，这里指定一个默认的分区名称，值为0。 提示：分区可以在创建表的时候一次性创建完，也可以后面再加，后面再加比较灵活，这段代码给出的分区是list分区，分区的类型还有range、list和key，会单独写一篇文章去讲。 创建好分区后，我们通过语句 123SELECT PARTITION_NAME,TABLE_ROWSFROM INFORMATION_SCHEMA.PARTITIONSWHERE TABLE_NAME = 'user_info'; 可以查看表分区情况如下：可以看到现在的p_default分区里的数据条数为0，我们现在增加两个新的分区 12alter table user_info add partition (partition p_202001 values in (202001));alter table user_info add partition (partition p_202002 values in (202002)); 我们可以看到多了两个分区。 在分区中插入数据现在我们插入数据 12345INSERT INTOuser_infoVALUES(202001,01,'mike'),(202002,02,'jack'); 查看分区：可以看到，time为202001的数据会自动添加到p_202001的分区当中，也就是说，将数据插入表中的时候，符合分区指定值的数据会自动添加到指定分区当中。 删除分区如果表里的数据非常大，在没有分区的情况下，要删除2020年1月的数据，我们需要这样去写： 123DELETEFROM user_infowhere time=202001 这样操作会遍历数据库，如果用分区： 1alter table user_info drop partition p_202001; 这样可以直接删除p_202001分区所在文件，可以大大提高效率 以上是对分区的简单介绍，除了用分区来查询效率，还可以建立索引 建立索引建立索引可以有效加快查询速度，常见的索引方法有B tree，B+ tree等，关于索引的方法和区别单独放在一篇文章去讲，平时用的最多的是B+ tree索引（mysql），mongodb没有B+ tree索引，只有B tree索引，与二者面向的功能不同有关，这里只讲最常用到的B+ tree索引。建立索引非常简单，在navigate中，右键表—&gt;设计表—&gt;索引—&gt;添加索引索引的类型有四种（索引类型与分区类型放在另一篇文章），常用的是normal。索引方法选择BTREE（mysql中实际为B+ TREE）。 提示：索引虽然可以大幅提高查询速度，但是索引是会占用硬盘空间的，如果一个表中为所有字段都加上索引，并不是一个明智的做法。一般根据常见查询需求建立联合索引。 优化表连接在处理大量数据的表时，有时会用到几个表之间的连接。我日常用到的方案有两个：1 避免使用left join，尽量使用inner join，不要使用outer joinleft join除了需要所有inner join的结果集以外还需要左表的所有没有关联上的数据。并且left join除了要求关联字段有索引以外，最好将小表作为左表，因为检索的循环次数更少，前提是你的业务逻辑没问题，因为不同的写法逻辑是不一样的。inner join会自动选择合适的表作为基础表，也仍然要求有关联字段索引，并且最好是int型检索效率更高。2 先用子查询，再去inner join网上整理得知内联表查询一般的执行过程是： 1、执行FROM语句2、执行ON过滤3、添加外部行4、执行where条件过滤5、执行group by分组语句6、执行having7、select列表8、执行distinct去重复数据9、执行order by字句10、执行limit字句 我们可以看到，mysql是先进行表的连接，如果是inner join就先将连接的表做笛卡尔积，然后在临时表中进行其他语句的执行。 12345678910SELECTtable_a.a,b,cFROM(SELECT *FROM table_aWHEREa&gt;0) K INNER JOIN table_b ON table_a.a = table_b.a 这里我们先把a表中需要的信息查询出来，作为临时表K，再用临时表K与b表连接，虽然增加了一次查询，但是如果a字段有索引，则建立临时表的速度是非常快的。 总结这是我的第一篇博客，有些地方写的可能驴唇不对马嘴，逻辑可能也不是很通顺，但是我会努力写下去的，记录自己的学习和工作上的心得，督促自己去学习更多，如果能帮助到其他小伙伴就更开心啦～","link":"/2020/05/27/mysql%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96/"}],"tags":[{"name":"‘mysql’","slug":"‘mysql’","link":"/tags/%E2%80%98mysql%E2%80%99/"},{"name":"查询优化","slug":"查询优化","link":"/tags/%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96/"}],"categories":[{"name":"mysql","slug":"mysql","link":"/categories/mysql/"}]}